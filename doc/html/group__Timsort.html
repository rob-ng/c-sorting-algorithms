<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sorting Algorithms: Timsorts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sorting Algorithms
   </div>
   <div id="projectbrief">Implementation of various sorting algorithms in C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Timsorts<div class="ingroups"><a class="el" href="group__SortingAlgorithm.html">Sorting Algorithms</a> &raquo; <a class="el" href="group__HybridSort.html">Hybrid Sorts</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Timsort implementations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1c9fca70060e37617156b89b387aa4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3">timsort</a> (void *arr, size_t nelems, size_t size, int(*compare)(const void *, const void *))</td></tr>
<tr class="memdesc:ga1c9fca70060e37617156b89b387aa4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort generic array using Timsort.  <a href="#ga1c9fca70060e37617156b89b387aa4d3">More...</a><br /></td></tr>
<tr class="separator:ga1c9fca70060e37617156b89b387aa4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdbb9c8c9cff36ac260a15b51080e47b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#gabdbb9c8c9cff36ac260a15b51080e47b">timsort_find_runs</a> (void *arr, size_t nelems, size_t size, int(*compare)(const void *, const void *), size_t minrun, <a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *merge_state)</td></tr>
<tr class="memdesc:gabdbb9c8c9cff36ac260a15b51080e47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find runs of either strictly descending or non-descending elements.  <a href="#gabdbb9c8c9cff36ac260a15b51080e47b">More...</a><br /></td></tr>
<tr class="separator:gabdbb9c8c9cff36ac260a15b51080e47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b690ab2bb67a139ba32a6715834952"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#ga77b690ab2bb67a139ba32a6715834952">timsort_check_invariants</a> (void *arr, size_t size, int(*compare)(const void *, const void *), <a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *merge_state)</td></tr>
<tr class="memdesc:ga77b690ab2bb67a139ba32a6715834952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that run invariants hold and update runs stack if they do not.  <a href="#ga77b690ab2bb67a139ba32a6715834952">More...</a><br /></td></tr>
<tr class="separator:ga77b690ab2bb67a139ba32a6715834952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3978be9f06411c3f9cd0bd597d64b555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#ga3978be9f06411c3f9cd0bd597d64b555">timsort_collapse_runs</a> (void *arr, size_t size, int(*compare)(const void *, const void *), <a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *merge_state)</td></tr>
<tr class="memdesc:ga3978be9f06411c3f9cd0bd597d64b555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge top two runs in run stack until only one run remains.  <a href="#ga3978be9f06411c3f9cd0bd597d64b555">More...</a><br /></td></tr>
<tr class="separator:ga3978be9f06411c3f9cd0bd597d64b555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62d32e069756222c797c569f08220237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTimsortRun.html">TimsortRun</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#ga62d32e069756222c797c569f08220237">timsort_merge_runs</a> (void *arr, size_t size, int(*compare)(const void *, const void *), <a class="el" href="structTimsortRun.html">TimsortRun</a> *frst, <a class="el" href="structTimsortRun.html">TimsortRun</a> *scnd, <a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *merge_state)</td></tr>
<tr class="memdesc:ga62d32e069756222c797c569f08220237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge 2 consecutive runs.  <a href="#ga62d32e069756222c797c569f08220237">More...</a><br /></td></tr>
<tr class="separator:ga62d32e069756222c797c569f08220237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d92f57e1b421c1110d15ea25492bb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#ga67d92f57e1b421c1110d15ea25492bb4">timsort_merge_runs_lo</a> (void *arr, size_t size, int(*compare)(const void *, const void *), size_t lo, size_t lo_len, size_t hi, size_t hi_len, <a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *merge_state)</td></tr>
<tr class="memdesc:ga67d92f57e1b421c1110d15ea25492bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge runs from left to right.  <a href="#ga67d92f57e1b421c1110d15ea25492bb4">More...</a><br /></td></tr>
<tr class="separator:ga67d92f57e1b421c1110d15ea25492bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59524f2247f32032582b8f17ab93a1f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#ga59524f2247f32032582b8f17ab93a1f6">timsort_gallop_right</a> (void *src, size_t size, int(*compare)(const void *, const void *), int base, int limit, void *target)</td></tr>
<tr class="memdesc:ga59524f2247f32032582b8f17ab93a1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gallop left-&gt;right to find number of elements in source array less than target.  <a href="#ga59524f2247f32032582b8f17ab93a1f6">More...</a><br /></td></tr>
<tr class="separator:ga59524f2247f32032582b8f17ab93a1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab79f5bad70cecab915e4a564516cf5a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#gab79f5bad70cecab915e4a564516cf5a8">timsort_merge_runs_hi</a> (void *arr, size_t size, int(*compare)(const void *, const void *), size_t lo, size_t lo_len, size_t hi, size_t hi_len, <a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *merge_state)</td></tr>
<tr class="memdesc:gab79f5bad70cecab915e4a564516cf5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge runs from right to left.  <a href="#gab79f5bad70cecab915e4a564516cf5a8">More...</a><br /></td></tr>
<tr class="separator:gab79f5bad70cecab915e4a564516cf5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac60918d0e6930ae4dd66dc5376b74649"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#gac60918d0e6930ae4dd66dc5376b74649">timsort_gallop_left</a> (void *src, size_t size, int(*compare)(const void *, const void *), int base, int limit, void *target)</td></tr>
<tr class="memdesc:gac60918d0e6930ae4dd66dc5376b74649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gallop right-&gt;left to find number of elements in source array greater than target.  <a href="#gac60918d0e6930ae4dd66dc5376b74649">More...</a><br /></td></tr>
<tr class="separator:gac60918d0e6930ae4dd66dc5376b74649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1b40d5d91736aa4b5362896cdc68f3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#ga7d1b40d5d91736aa4b5362896cdc68f3">timsort_minrun</a> (size_t nelems)</td></tr>
<tr class="memdesc:ga7d1b40d5d91736aa4b5362896cdc68f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find minimum run size to use in timsort.  <a href="#ga7d1b40d5d91736aa4b5362896cdc68f3">More...</a><br /></td></tr>
<tr class="separator:ga7d1b40d5d91736aa4b5362896cdc68f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b25eb89bf429f324330ee07a9c9400"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Timsort.html#gac9b25eb89bf429f324330ee07a9c9400">timsort_binary_search</a> (void *arr, size_t size, int(*compare)(const void *, const void *), size_t lo, size_t hi, void *target)</td></tr>
<tr class="memdesc:gac9b25eb89bf429f324330ee07a9c9400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find position of element within array using binary search.  <a href="#gac9b25eb89bf429f324330ee07a9c9400">More...</a><br /></td></tr>
<tr class="separator:gac9b25eb89bf429f324330ee07a9c9400"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Timsort implementations. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1c9fca70060e37617156b89b387aa4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c9fca70060e37617156b89b387aa4d3">&#9670;&nbsp;</a></span>timsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timsort </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nelems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort generic array using Timsort. </p>
<p>Timsort (developed by Tim Peters) is a hybrid stable sorting algorithm. Timsort uses a combination of insertion sort and merge sort to first organize the array into roughly equal length runs of ascending elements and then merge those runs into a single sorted run. The algorithm proceeds through the following steps:</p>
<ul>
<li>If array to sort is shorter than 64 elements:<ol type="1">
<li>Defer to insertion sort.</li>
</ol>
</li>
<li>Otherwise<ol type="1">
<li>Calculate the minimum run length.<ul>
<li>Minimum run length is chosen such that (array length / minimum run) is equal to (or slightly less than) 2 to some power. Doing so ensures that merges remain balanced for random data (where most runs are likely to have length equal to the minimum run).</li>
</ul>
</li>
<li>Initialize a struct to represent merge state for the duration of the sort.</li>
<li>Find (or create if necessary) runs of at least minrun length. All runs are sorted to be ascending if they aren't already.<ul>
<li>On finding a run, push it onto the runs stack and check to see if run invariants still hold. Merge runs until they do.</li>
</ul>
</li>
<li>Collapse the remaining runs in the runs stack into a single sorted run.</li>
</ol>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array to be sorted. </td></tr>
    <tr><td class="paramname">nelems</td><td>Number of elements in array. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in array. </td></tr>
    <tr><td class="paramname">compare</td><td>Function to compare elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga7d1b40d5d91736aa4b5362896cdc68f3" title="Find minimum run size to use in timsort. ">timsort_minrun</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#gabdbb9c8c9cff36ac260a15b51080e47b" title="Find runs of either strictly descending or non-descending elements. ">timsort_find_runs</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga77b690ab2bb67a139ba32a6715834952" title="Check that run invariants hold and update runs stack if they do not. ">timsort_check_invariants</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga3978be9f06411c3f9cd0bd597d64b555" title="Merge top two runs in run stack until only one run remains. ">timsort_collapse_runs</a> </dd></dl>

</div>
</div>
<a id="gac9b25eb89bf429f324330ee07a9c9400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9b25eb89bf429f324330ee07a9c9400">&#9670;&nbsp;</a></span>timsort_binary_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int timsort_binary_search </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find position of element within array using binary search. </p>
<p>Used in Timsort when galloping. When this version of binary search fails to find the element being search for, it just returns 'l'. Comparisons between the target and the value at arr[l] are left to galloping functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array to be searched. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in array. </td></tr>
    <tr><td class="paramname">compare</td><td>Function for comparing elements. </td></tr>
    <tr><td class="paramname">lo</td><td>Lower index bound for searching. </td></tr>
    <tr><td class="paramname">hi</td><td>Upper index bound for searching. </td></tr>
    <tr><td class="paramname">target</td><td>Element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index where element either is, or should be, located in the array.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3" title="Sort generic array using Timsort. ">timsort</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#gac60918d0e6930ae4dd66dc5376b74649" title="Gallop right-&gt;left to find number of elements in source array greater than target. ">timsort_gallop_left</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga59524f2247f32032582b8f17ab93a1f6" title="Gallop left-&gt;right to find number of elements in source array less than target. ">timsort_gallop_right</a> </dd></dl>

</div>
</div>
<a id="ga77b690ab2bb67a139ba32a6715834952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77b690ab2bb67a139ba32a6715834952">&#9670;&nbsp;</a></span>timsort_check_invariants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timsort_check_invariants </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *&#160;</td>
          <td class="paramname"><em>merge_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that run invariants hold and update runs stack if they do not. </p>
<p>Suppose the runs stack has at least 3 runs and let X, Y and Z be the top 3 runs, ordered from right to left. Then the following must hold:</p><ol type="1">
<li>|X| &gt; |Y| + |Z|</li>
<li>|Y| &gt; |Z| If either invariant fails to hold, merge Y with smaller of X and Z and push new merged value onto stack, maintaing order.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array containing runs. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in array. </td></tr>
    <tr><td class="paramname">compare</td><td>Function to compare elements. </td></tr>
    <tr><td class="paramname">merge_state</td><td>Struct containing information about merges and runs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3" title="Sort generic array using Timsort. ">timsort</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga77b690ab2bb67a139ba32a6715834952" title="Check that run invariants hold and update runs stack if they do not. ">timsort_check_invariants</a> </dd></dl>

</div>
</div>
<a id="ga3978be9f06411c3f9cd0bd597d64b555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3978be9f06411c3f9cd0bd597d64b555">&#9670;&nbsp;</a></span>timsort_collapse_runs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timsort_collapse_runs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *&#160;</td>
          <td class="paramname"><em>merge_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge top two runs in run stack until only one run remains. </p>
<p>Once all the runs have been merged, the array will be fully sorted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array containing runs. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in array. </td></tr>
    <tr><td class="paramname">compare</td><td>Function to compare elements. </td></tr>
    <tr><td class="paramname">merge_state</td><td>Struct containing information about merges and runs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3" title="Sort generic array using Timsort. ">timsort</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga62d32e069756222c797c569f08220237" title="Merge 2 consecutive runs. ">timsort_merge_runs</a> </dd></dl>

</div>
</div>
<a id="gabdbb9c8c9cff36ac260a15b51080e47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdbb9c8c9cff36ac260a15b51080e47b">&#9670;&nbsp;</a></span>timsort_find_runs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timsort_find_runs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nelems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minrun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *&#160;</td>
          <td class="paramname"><em>merge_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find runs of either strictly descending or non-descending elements. </p>
<p>Runs must be at least minrun elements long. If a run is shorter than this, it is extended using consecutive elements. There is one exception; the last run may be shorter if there are not enough elements to pad out its length.</p>
<p>Importantly, all runs must be non-descending before they can be pushed onto the runs stack - runs which are descending are reveresed before they are pushed.</p>
<p>Once a new run has been found and pushed on the runs stack, the function calls <a class="el" href="group__Timsort.html#ga77b690ab2bb67a139ba32a6715834952" title="Check that run invariants hold and update runs stack if they do not. ">timsort_check_invariants()</a> to ensure that the run invariants still hold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array to search for runs. </td></tr>
    <tr><td class="paramname">nelems</td><td>Number of elements in array. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in array. </td></tr>
    <tr><td class="paramname">compare</td><td>Function to compare elements. </td></tr>
    <tr><td class="paramname">minrun</td><td>Minimum acceptable run length. </td></tr>
    <tr><td class="paramname">merge_state</td><td>Struct containing information about merges and runs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3" title="Sort generic array using Timsort. ">timsort</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga77b690ab2bb67a139ba32a6715834952" title="Check that run invariants hold and update runs stack if they do not. ">timsort_check_invariants</a> </dd></dl>

</div>
</div>
<a id="gac60918d0e6930ae4dd66dc5376b74649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac60918d0e6930ae4dd66dc5376b74649">&#9670;&nbsp;</a></span>timsort_gallop_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int timsort_gallop_left </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gallop right-&gt;left to find number of elements in source array greater than target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Array to gallop over. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in array. </td></tr>
    <tr><td class="paramname">compare</td><td>Function to compare elements. </td></tr>
    <tr><td class="paramname">base</td><td>Index to begin gallop. </td></tr>
    <tr><td class="paramname">limit</td><td>Index limit for galloping. </td></tr>
    <tr><td class="paramname">target</td><td>Target element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in souce array greater than target.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3" title="Sort generic array using Timsort. ">timsort</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#gab79f5bad70cecab915e4a564516cf5a8" title="Merge runs from right to left. ">timsort_merge_runs_hi</a> </dd></dl>

</div>
</div>
<a id="ga59524f2247f32032582b8f17ab93a1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59524f2247f32032582b8f17ab93a1f6">&#9670;&nbsp;</a></span>timsort_gallop_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int timsort_gallop_right </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gallop left-&gt;right to find number of elements in source array less than target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Array to gallop over. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in array. </td></tr>
    <tr><td class="paramname">compare</td><td>Function to compare elements. </td></tr>
    <tr><td class="paramname">base</td><td>Index to begin gallop. </td></tr>
    <tr><td class="paramname">limit</td><td>Index limit for galloping. </td></tr>
    <tr><td class="paramname">target</td><td>Target element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in source array less than target.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3" title="Sort generic array using Timsort. ">timsort</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga67d92f57e1b421c1110d15ea25492bb4" title="Merge runs from left to right. ">timsort_merge_runs_lo</a> </dd></dl>

</div>
</div>
<a id="ga62d32e069756222c797c569f08220237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62d32e069756222c797c569f08220237">&#9670;&nbsp;</a></span>timsort_merge_runs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTimsortRun.html">TimsortRun</a>* timsort_merge_runs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTimsortRun.html">TimsortRun</a> *&#160;</td>
          <td class="paramname"><em>frst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTimsortRun.html">TimsortRun</a> *&#160;</td>
          <td class="paramname"><em>scnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *&#160;</td>
          <td class="paramname"><em>merge_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge 2 consecutive runs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array containing runs. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in array. </td></tr>
    <tr><td class="paramname">compare</td><td>Function to compare elements. </td></tr>
    <tr><td class="paramname">frst</td><td>Leftmost run. </td></tr>
    <tr><td class="paramname">scnd</td><td>Rightmost run. </td></tr>
    <tr><td class="paramname">merge_state</td><td>Struct containing information about merges and runs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to first run, now with length updated to include second's.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3" title="Sort generic array using Timsort. ">timsort</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga77b690ab2bb67a139ba32a6715834952" title="Check that run invariants hold and update runs stack if they do not. ">timsort_check_invariants</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga3978be9f06411c3f9cd0bd597d64b555" title="Merge top two runs in run stack until only one run remains. ">timsort_collapse_runs</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga67d92f57e1b421c1110d15ea25492bb4" title="Merge runs from left to right. ">timsort_merge_runs_lo</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#gab79f5bad70cecab915e4a564516cf5a8" title="Merge runs from right to left. ">timsort_merge_runs_hi</a> </dd></dl>

</div>
</div>
<a id="gab79f5bad70cecab915e4a564516cf5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab79f5bad70cecab915e4a564516cf5a8">&#9670;&nbsp;</a></span>timsort_merge_runs_hi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timsort_merge_runs_hi </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lo_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hi_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *&#160;</td>
          <td class="paramname"><em>merge_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge runs from right to left. </p>
<p>Called when the rightmost run is smaller than the leftmost run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array containing runs. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in array. </td></tr>
    <tr><td class="paramname">compare</td><td>Function to compare elements. </td></tr>
    <tr><td class="paramname">lo</td><td>Lower bound of merge (inclusive). </td></tr>
    <tr><td class="paramname">lo_len</td><td>Length of larger leftmost run. </td></tr>
    <tr><td class="paramname">hi</td><td>Upper bound of merge (inclusive). </td></tr>
    <tr><td class="paramname">hi_len</td><td>Length of smaller rightmost run. </td></tr>
    <tr><td class="paramname">merge_state</td><td>Struct containing information about merges and runs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3" title="Sort generic array using Timsort. ">timsort</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga62d32e069756222c797c569f08220237" title="Merge 2 consecutive runs. ">timsort_merge_runs</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#gac60918d0e6930ae4dd66dc5376b74649" title="Gallop right-&gt;left to find number of elements in source array greater than target. ">timsort_gallop_left</a> </dd></dl>

</div>
</div>
<a id="ga67d92f57e1b421c1110d15ea25492bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d92f57e1b421c1110d15ea25492bb4">&#9670;&nbsp;</a></span>timsort_merge_runs_lo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timsort_merge_runs_lo </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lo_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hi_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTimsortMergeState.html">TimsortMergeState</a> *&#160;</td>
          <td class="paramname"><em>merge_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge runs from left to right. </p>
<p>Called when the leftmost run is smaller than the rightmost run. There are two modes in which merges can be performed:</p>
<p>Standard mode: Standard merge sort where elements are compared one-to-one. During this mode, we keep track of the "winning" array. If an array has "won" more than the merge_state-&gt;min_gallop, we enter galloping mode.</p>
<p>Galloping Mode: Let A and B be two runs, A the smaller run. Let k be the index to merge into in the main array, l be the initial index of A, and r the initial index of B. We first find the location of A[l] in B. We then merge values from B up to this index into the main array (the number of elements is slice1). We then merge A[l]. We then increment k, l, and r to account for the merged elements. Next, we find the location of B[r] in A and perform a similar operation (number of elements from A is slice2). Again, we increment k, l and r to account for the merged elements. After all of this, we check that slice1 and slice2 are both &gt;= merge_state-&gt;min_run. If so, we decrement merge_state-&gt;min_run to make entering into galloping mode easier. If not, we increment merge_state-&gt;min_run to make entering galloping mode harder and we exit out of galloping mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array containing runs. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in array. </td></tr>
    <tr><td class="paramname">compare</td><td>Function to compare elements. </td></tr>
    <tr><td class="paramname">lo</td><td>Lower index bound of merge (inclusive). </td></tr>
    <tr><td class="paramname">lo_len</td><td>Length of smaller leftmost run. </td></tr>
    <tr><td class="paramname">hi</td><td>Upper index bound of merge (inclusive). </td></tr>
    <tr><td class="paramname">hi_len</td><td>Length of larger rightmost run. </td></tr>
    <tr><td class="paramname">merge_state</td><td>Struct containing information about merges and runs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3" title="Sort generic array using Timsort. ">timsort</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga62d32e069756222c797c569f08220237" title="Merge 2 consecutive runs. ">timsort_merge_runs</a> </dd>
<dd>
<a class="el" href="group__Timsort.html#ga59524f2247f32032582b8f17ab93a1f6" title="Gallop left-&gt;right to find number of elements in source array less than target. ">timsort_gallop_right</a> </dd></dl>

</div>
</div>
<a id="ga7d1b40d5d91736aa4b5362896cdc68f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d1b40d5d91736aa4b5362896cdc68f3">&#9670;&nbsp;</a></span>timsort_minrun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t timsort_minrun </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nelems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find minimum run size to use in timsort. </p>
<p>The minimum run size is given by the 6 most significant bits of the array's length. Consequently, minrun will range between 32 and 64 inclusive, and any array with length &lt; 64 will have minimum run size equal to their entire length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nelems</td><td>Number of elements in array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of minimum run.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Timsort.html#ga1c9fca70060e37617156b89b387aa4d3" title="Sort generic array using Timsort. ">timsort</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
