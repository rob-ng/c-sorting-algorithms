\hypertarget{group__MergeSort}{}\section{Merge Sorts}
\label{group__MergeSort}\index{Merge Sorts@{Merge Sorts}}


Merge sort implementations.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group__MergeSort_ga9e7f6cf0117297b84135e76a00711d82}{merge\+\_\+sort} (void $\ast$arr, size\+\_\+t nelems, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$))
\begin{DoxyCompactList}\small\item\em Sort generic array using merge sort. \end{DoxyCompactList}\item 
void \hyperlink{group__MergeSort_ga4094395ddbe4c74b46b6f011a83ceb46}{merge\+\_\+sort\+\_\+recursive} (void $\ast$arr, void $\ast$aux, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t hi)
\begin{DoxyCompactList}\small\item\em Recursively perform merge sort. \end{DoxyCompactList}\item 
void \hyperlink{group__MergeSort_ga1b4d8f0a083e4f0d30291ce8829ba6fe}{merge\+\_\+sort\+\_\+merge} (void $\ast$arr, void $\ast$aux, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t mid, size\+\_\+t hi)
\begin{DoxyCompactList}\small\item\em Merge subarrays by updating aux with sorted values taken from arr. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Merge sort implementations. 



\subsection{Function Documentation}
\mbox{\Hypertarget{group__MergeSort_ga9e7f6cf0117297b84135e76a00711d82}\label{group__MergeSort_ga9e7f6cf0117297b84135e76a00711d82}} 
\index{Merge Sorts@{Merge Sorts}!merge\+\_\+sort@{merge\+\_\+sort}}
\index{merge\+\_\+sort@{merge\+\_\+sort}!Merge Sorts@{Merge Sorts}}
\subsubsection{\texorpdfstring{merge\+\_\+sort()}{merge\_sort()}}
{\footnotesize\ttfamily void merge\+\_\+sort (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{size\+\_\+t}]{nelems,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare }\end{DoxyParamCaption})}



Sort generic array using merge sort. 

Merge sort is not efficient for small arrays. As such, merge sort is only performed if the length of the array is above L\+E\+N\+G\+T\+H\+\_\+\+T\+H\+R\+E\+S\+H\+O\+LD.

The function creates an auxillary array to make merging more efficient. Without the auxillary array, each merge would require updating the auxillary array with the current values of the main array in the interval \mbox{[}lo, hi\mbox{]} before performing comparisons. By instead alternating the roles of the main and auxillary array between merges, we can skip this process entirely, as the array which is used for comparisons in the next call is the array to which values were copied in the previous call.

Because of this, we also need make the initial call to merge\+\_\+sort\+\_\+sort() with the main and auxillary arrays swapped. This is so that the first merge involves copying values into the main array from the auxillary array.


\begin{DoxyParams}{Parameters}
{\em arr} & Array to be sorted. \\
\hline
{\em nelems} & Number of elements in the array. \\
\hline
{\em size} & Size of each element in the array. \\
\hline
{\em compare} & Function to be used to compare elements. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__MergeSort_ga1b4d8f0a083e4f0d30291ce8829ba6fe}\label{group__MergeSort_ga1b4d8f0a083e4f0d30291ce8829ba6fe}} 
\index{Merge Sorts@{Merge Sorts}!merge\+\_\+sort\+\_\+merge@{merge\+\_\+sort\+\_\+merge}}
\index{merge\+\_\+sort\+\_\+merge@{merge\+\_\+sort\+\_\+merge}!Merge Sorts@{Merge Sorts}}
\subsubsection{\texorpdfstring{merge\+\_\+sort\+\_\+merge()}{merge\_sort\_merge()}}
{\footnotesize\ttfamily void merge\+\_\+sort\+\_\+merge (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{void $\ast$}]{aux,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare,  }\item[{size\+\_\+t}]{lo,  }\item[{size\+\_\+t}]{mid,  }\item[{size\+\_\+t}]{hi }\end{DoxyParamCaption})}



Merge subarrays by updating aux with sorted values taken from arr. 


\begin{DoxyParams}{Parameters}
{\em arr} & Array from which values are copied. \\
\hline
{\em aux} & Array to which sorted values are copied. \\
\hline
{\em size} & Size of each element in either array. \\
\hline
{\em compare} & Function to be used to compare elements. \\
\hline
{\em lo} & Lower bound of the sub array. \\
\hline
{\em mid} & Midpoint of the subarray. \\
\hline
{\em hi} & Higher bound of the subarry. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__MergeSort_ga4094395ddbe4c74b46b6f011a83ceb46}\label{group__MergeSort_ga4094395ddbe4c74b46b6f011a83ceb46}} 
\index{Merge Sorts@{Merge Sorts}!merge\+\_\+sort\+\_\+recursive@{merge\+\_\+sort\+\_\+recursive}}
\index{merge\+\_\+sort\+\_\+recursive@{merge\+\_\+sort\+\_\+recursive}!Merge Sorts@{Merge Sorts}}
\subsubsection{\texorpdfstring{merge\+\_\+sort\+\_\+recursive()}{merge\_sort\_recursive()}}
{\footnotesize\ttfamily void merge\+\_\+sort\+\_\+recursive (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{void $\ast$}]{aux,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare,  }\item[{size\+\_\+t}]{lo,  }\item[{size\+\_\+t}]{hi }\end{DoxyParamCaption})}



Recursively perform merge sort. 

Merge sort is only perfomed if current index interval \mbox{[}lo, hi\mbox{]} is sufficiently large. If it isn\textquotesingle{}t, insertion sort is used to sort the array in that interval.

Note that the merge\+\_\+sort\+\_\+sort() and \hyperlink{group__MergeSort_ga1b4d8f0a083e4f0d30291ce8829ba6fe}{merge\+\_\+sort\+\_\+merge()} calls swap the order of arr and aux. This ensures that the aux array (I\+N\+TO which values are copied from arr in merge) is the array F\+R\+OM which values are copied in the next merge. See \hyperlink{group__MergeSort_ga9e7f6cf0117297b84135e76a00711d82}{merge\+\_\+sort()} documentation for why this is done.

\begin{DoxyNote}{Note}
The parameters \textquotesingle{}hi\textquotesingle{} and \textquotesingle{}lo\textquotesingle{} are multiples of \textquotesingle{}size\textquotesingle{}. As such, calculating \textquotesingle{}mid\textquotesingle{} is slightly more involved as it must also be a multiple of \textquotesingle{}size\textquotesingle{}.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em arr} & Array from which values will be copied. \\
\hline
{\em aux} & Array into which values will be copied. \\
\hline
{\em size} & Size of each element in either array. \\
\hline
{\em compare} & Function to compare elements. \\
\hline
{\em lo} & Lower bound of subarray (inclusive). \\
\hline
{\em hi} & Upper bound of subarray (inclusive). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__MergeSort_ga9e7f6cf0117297b84135e76a00711d82}{merge\+\_\+sort()} 

\hyperlink{group__MergeSort_ga1b4d8f0a083e4f0d30291ce8829ba6fe}{merge\+\_\+sort\+\_\+merge()} 
\end{DoxySeeAlso}
