\hypertarget{sorting_8c}{}\section{src/sorting.c File Reference}
\label{sorting_8c}\index{src/sorting.\+c@{src/sorting.\+c}}


Sorting implementation.  


{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$limits.\+h$>$}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
{\ttfamily \#include \char`\"{}sorting.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}stack.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}doxygen.\+h\char`\"{}}\newline
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structTimsortRun}{Timsort\+Run}
\begin{DoxyCompactList}\small\item\em Struct to represent run during Timsort. \end{DoxyCompactList}\item 
struct \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State}
\begin{DoxyCompactList}\small\item\em Struct to represent merge state during Timsort. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group__InsertionSort_ga262ca6566c76d4587cba88441880a293}{insert\+\_\+sort} (void $\ast$arr, size\+\_\+t nelems, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$))
\begin{DoxyCompactList}\small\item\em Sort generic array using insertion sort. \end{DoxyCompactList}\item 
void \hyperlink{group__InsertionSort_gad147d05ac7625135f328ce4924ac2553}{insert\+\_\+sort\+\_\+partial} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t hi)
\begin{DoxyCompactList}\small\item\em Sort generic contiguous subarray using insertion sort. \end{DoxyCompactList}\item 
void \hyperlink{group__InsertionSort_gaac4076ef31a1984eb307e21d3ce5df0a}{binary\+\_\+insert\+\_\+sort} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t hi)
\begin{DoxyCompactList}\small\item\em Sort generic contiguous subarray using binary insertion sort. \end{DoxyCompactList}\item 
void \hyperlink{group__SelectionSort_ga95d65a1979dccdbd2b5b599d0eeef339}{select\+\_\+sort} (void $\ast$arr, size\+\_\+t nelems, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$))
\begin{DoxyCompactList}\small\item\em Sort generic array using selection sort. \end{DoxyCompactList}\item 
void \hyperlink{group__CombSort_ga98c1ffdc88b96dcb5f9a0d7d1e7a9622}{comb\+\_\+sort} (void $\ast$arr, size\+\_\+t nelems, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$))
\begin{DoxyCompactList}\small\item\em Sort generic array using comb sort. \end{DoxyCompactList}\item 
void \hyperlink{group__MergeSort_ga9e7f6cf0117297b84135e76a00711d82}{merge\+\_\+sort} (void $\ast$arr, size\+\_\+t nelems, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$))
\begin{DoxyCompactList}\small\item\em Sort generic array using merge sort. \end{DoxyCompactList}\item 
void \hyperlink{group__MergeSort_ga04476f6fd4b5920aab75a4f58c0d9af1}{merge\+\_\+sort\+\_\+sort} (void $\ast$arr, void $\ast$aux, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t hi)
\begin{DoxyCompactList}\small\item\em Recursively perform merge sort. \end{DoxyCompactList}\item 
void \hyperlink{group__MergeSort_ga1b4d8f0a083e4f0d30291ce8829ba6fe}{merge\+\_\+sort\+\_\+merge} (void $\ast$arr, void $\ast$aux, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t mid, size\+\_\+t hi)
\begin{DoxyCompactList}\small\item\em Merge subarrays by updating aux with sorted values taken from arr. \end{DoxyCompactList}\item 
void \hyperlink{group__QuickSort_gacc1abed6e3519de02d60503e0b214932}{quick\+\_\+sort} (void $\ast$arr, size\+\_\+t nelems, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$))
\begin{DoxyCompactList}\small\item\em Sort generic array using quicksort. \end{DoxyCompactList}\item 
void \hyperlink{group__QuickSort_ga4a465523bf71478872301ee552edb403}{quick\+\_\+sort\+\_\+sort} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t hi)
\begin{DoxyCompactList}\small\item\em Recursively perform quicksort. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{group__QuickSort_gae45617fa4741c13bc601fe2a984fdc2c}{quick\+\_\+sort\+\_\+partition} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t hi)
\begin{DoxyCompactList}\small\item\em Partition subarray around pivot element. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort} (void $\ast$arr, size\+\_\+t nelems, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$))
\begin{DoxyCompactList}\small\item\em Sort generic array using Timsort. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_gabdbb9c8c9cff36ac260a15b51080e47b}{timsort\+\_\+find\+\_\+runs} (void $\ast$arr, size\+\_\+t nelems, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t minrun, \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$merge\+\_\+state)
\begin{DoxyCompactList}\small\item\em Find runs of either strictly descending or non-\/descending elements. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_ga77b690ab2bb67a139ba32a6715834952}{timsort\+\_\+check\+\_\+invariants} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$merge\+\_\+state)
\begin{DoxyCompactList}\small\item\em Check that run invariants hold and update runs stack if they do not. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_ga3978be9f06411c3f9cd0bd597d64b555}{timsort\+\_\+collapse\+\_\+runs} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$merge\+\_\+state)
\begin{DoxyCompactList}\small\item\em Merge top two runs in run stack until only one run remains. \end{DoxyCompactList}\item 
\hyperlink{structTimsortRun}{Timsort\+Run} $\ast$ \hyperlink{group__Timsort_ga62d32e069756222c797c569f08220237}{timsort\+\_\+merge\+\_\+runs} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), \hyperlink{structTimsortRun}{Timsort\+Run} $\ast$frst, \hyperlink{structTimsortRun}{Timsort\+Run} $\ast$scnd, \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$merge\+\_\+state)
\begin{DoxyCompactList}\small\item\em Merge 2 consecutive runs. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_ga67d92f57e1b421c1110d15ea25492bb4}{timsort\+\_\+merge\+\_\+runs\+\_\+lo} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t lo\+\_\+len, size\+\_\+t hi, size\+\_\+t hi\+\_\+len, \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$merge\+\_\+state)
\begin{DoxyCompactList}\small\item\em Merge runs from left to right. \end{DoxyCompactList}\item 
int \hyperlink{group__Timsort_ga59524f2247f32032582b8f17ab93a1f6}{timsort\+\_\+gallop\+\_\+right} (void $\ast$src, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), int base, int limit, void $\ast$target)
\begin{DoxyCompactList}\small\item\em Gallop left-\/$>$right to find number of elements in source array less than target. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_gab79f5bad70cecab915e4a564516cf5a8}{timsort\+\_\+merge\+\_\+runs\+\_\+hi} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t lo\+\_\+len, size\+\_\+t hi, size\+\_\+t hi\+\_\+len, \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$merge\+\_\+state)
\begin{DoxyCompactList}\small\item\em Merge runs from right to left. \end{DoxyCompactList}\item 
int \hyperlink{group__Timsort_gac60918d0e6930ae4dd66dc5376b74649}{timsort\+\_\+gallop\+\_\+left} (void $\ast$src, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), int base, int limit, void $\ast$target)
\begin{DoxyCompactList}\small\item\em Gallop right-\/$>$left to find number of elements in source array greater than target. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{group__Timsort_ga7d1b40d5d91736aa4b5362896cdc68f3}{timsort\+\_\+minrun} (size\+\_\+t nelems)
\begin{DoxyCompactList}\small\item\em Find minimum run size to use in timsort. \end{DoxyCompactList}\item 
int \hyperlink{group__Timsort_gac9b25eb89bf429f324330ee07a9c9400}{timsort\+\_\+binary\+\_\+search} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t hi, void $\ast$target)
\begin{DoxyCompactList}\small\item\em Find position of element within array using binary search. \end{DoxyCompactList}\item 
void \hyperlink{group__SortingHelper_gac005eaa05ec80dbf1a0984d3d4fa80a8}{swap} (void $\ast$a, void $\ast$b, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Swap the values referenced by two pointers. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{group__SortingHelper_ga7ca72135e6d6f9e7af0ea60d653efb09}{median\+\_\+three} (void $\ast$arr, size\+\_\+t size, size\+\_\+t a, size\+\_\+t b, size\+\_\+t c, int($\ast$compare)(const void $\ast$, const void $\ast$))
\begin{DoxyCompactList}\small\item\em Find median of three elements in given array and return its index. \end{DoxyCompactList}\item 
void \hyperlink{group__SortingHelper_gae26181b67ffd4261a676f39624c3ce68}{reverse\+\_\+array} (void $\ast$arr, size\+\_\+t start, size\+\_\+t end, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Reverse given array. \end{DoxyCompactList}\item 
int \hyperlink{group__SortingHelper_gaf203a2e0f9fe91935ca226e8f038fb43}{bin\+\_\+search} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t hi, void $\ast$target)
\begin{DoxyCompactList}\small\item\em Search for an element using binary search in a contiguous subarray. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{group__SortingHelper_ga347d3eac5748d59424afd8566181fc27}{bin\+\_\+search\+\_\+loc} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t hi, void $\ast$target)
\begin{DoxyCompactList}\small\item\em Find location of target value in array using binary search. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Sorting implementation. 

