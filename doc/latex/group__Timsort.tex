\hypertarget{group__Timsort}{}\section{Timsorts}
\label{group__Timsort}\index{Timsorts@{Timsorts}}


Timsort implementations.  


\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structTimsortRun}{Timsort\+Run}
\begin{DoxyCompactList}\small\item\em Struct to represent run during Timsort. \end{DoxyCompactList}\item 
struct \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State}
\begin{DoxyCompactList}\small\item\em Struct to represent merge state during Timsort. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort} (void $\ast$arr, size\+\_\+t nelems, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$))
\begin{DoxyCompactList}\small\item\em Sort generic array using Timsort. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_ga17b4bb9f7e1875e9e9e4c250b5b83482}{timsort\+\_\+find\+\_\+runs} (void $\ast$arr, size\+\_\+t nelems, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t minrun, \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$ms)
\begin{DoxyCompactList}\small\item\em Find runs of elements in the array. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_ga739626860caf26ad6fbe52f9dcb0806c}{timsort\+\_\+check\+\_\+invariants} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$ms)
\begin{DoxyCompactList}\small\item\em Maintain run invariants to ensure stable, balanced merges. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_gaf7991b9ef4ee31db5ae9f1fba5c04a15}{timsort\+\_\+collapse\+\_\+runs} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$ms)
\begin{DoxyCompactList}\small\item\em Merge top two runs in run stack until only one run remains. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_ga08929ad9e29cde3f24660fef3b08191c}{timsort\+\_\+merge\+\_\+runs} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), \hyperlink{structTimsortRun}{Timsort\+Run} $\ast$left, \hyperlink{structTimsortRun}{Timsort\+Run} $\ast$right, \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$ms)
\begin{DoxyCompactList}\small\item\em Merge two consecutive runs. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_ga9ed838122eff00630e9551003d73a56f}{timsort\+\_\+merge\+\_\+runs\+\_\+lo} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t lo\+\_\+len, size\+\_\+t hi, size\+\_\+t hi\+\_\+len, \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$ms)
\begin{DoxyCompactList}\small\item\em Merge two consecutive runs from left to right. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{group__Timsort_gaf272b7c7b32279bc6aa2010330e7d980}{timsort\+\_\+gallop\+\_\+right} (void $\ast$src, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t base, size\+\_\+t limit, void $\ast$target)
\begin{DoxyCompactList}\small\item\em Gallop left to right to find slice of elements in source array less than target. \end{DoxyCompactList}\item 
void \hyperlink{group__Timsort_ga5f8c1d718a58791f523430113eb5616e}{timsort\+\_\+merge\+\_\+runs\+\_\+hi} (void $\ast$arr, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t lo, size\+\_\+t lo\+\_\+len, size\+\_\+t hi, size\+\_\+t hi\+\_\+len, \hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$ms)
\begin{DoxyCompactList}\small\item\em Merge two consecutive runs from right to left. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{group__Timsort_ga61e102d0fe24f871260f90f9e40ba807}{timsort\+\_\+gallop\+\_\+left} (void $\ast$src, size\+\_\+t size, int($\ast$compare)(const void $\ast$, const void $\ast$), size\+\_\+t base, size\+\_\+t limit, void $\ast$target)
\begin{DoxyCompactList}\small\item\em Gallop right to left to find slice of elements in source array greater than target. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{group__Timsort_ga7d1b40d5d91736aa4b5362896cdc68f3}{timsort\+\_\+minrun} (size\+\_\+t nelems)
\begin{DoxyCompactList}\small\item\em Find minimum run size to use in timsort. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Timsort implementations. 



\subsection{Function Documentation}
\mbox{\Hypertarget{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}\label{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}} 
\index{Timsorts@{Timsorts}!timsort@{timsort}}
\index{timsort@{timsort}!Timsorts@{Timsorts}}
\subsubsection{\texorpdfstring{timsort()}{timsort()}}
{\footnotesize\ttfamily void timsort (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{size\+\_\+t}]{nelems,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare }\end{DoxyParamCaption})}



Sort generic array using Timsort. 

Timsort (developed by Tim Peters) is a hybrid stable sorting algorithm, combining insertion sort and an optimized merge sort. The algorithm proceeds as follows\+:


\begin{DoxyItemize}
\item If array to sort is shorter than 64 elements\+:
\begin{DoxyEnumerate}
\item Defer to insertion sort.
\begin{DoxyItemize}
\item When array is this short, minrun will equal the length of the array. As such, timsort offers no benefit over insertion sort in this case.
\end{DoxyItemize}
\end{DoxyEnumerate}
\item Otherwise
\begin{DoxyEnumerate}
\item Calculate the minimum run length.
\begin{DoxyItemize}
\item Minimum run length is chosen such that (array length / minimum run) is equal to (or slightly less than) 2 to some power. Doing so ensures that merges remain balanced for random data (where most runs are likely to have length equal to the minimum run).
\end{DoxyItemize}
\item Initialize a struct to represent merge state for the duration of the sort.
\item Find (or create if necessary) runs of at least minrun length. All runs are sorted to be ascending if they aren\textquotesingle{}t already.
\begin{DoxyItemize}
\item On finding a run, push it onto the runs stack. Once there, check that the run invariants still hold. If they do not, perform specific merge operations until they do. Maintaining run invariants ensures that the runs stack is kept small, that the sort is stable, and that runs are kept at similar sizes for more balanced merges.
\end{DoxyItemize}
\item Merge the remaining runs in the runs stack into a single sorted run.
\end{DoxyEnumerate}
\end{DoxyItemize}

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000001}{Todo}]The runs array is much larger than it needs to be. Technically, the number of unmerged runs shouldn\textquotesingle{}t grow larger than log base phi of N, where phi = (1 + sqrt(5))/2 (golden ratio). However, computing this for large N is expensive, and so for the moment I\textquotesingle{}ve opted only to use (N / minrun) + 1. This value is the maximum number of unmerged runs that could exist in the array without merging. \end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em arr} & Array to be sorted. \\
\hline
{\em nelems} & Number of elements in array. \\
\hline
{\em size} & Size of each element in array. \\
\hline
{\em compare} & Function to compare elements. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__Timsort_ga7d1b40d5d91736aa4b5362896cdc68f3}{timsort\+\_\+minrun()} 

\hyperlink{group__Timsort_ga17b4bb9f7e1875e9e9e4c250b5b83482}{timsort\+\_\+find\+\_\+runs()} 

\hyperlink{group__Timsort_ga739626860caf26ad6fbe52f9dcb0806c}{timsort\+\_\+check\+\_\+invariants()} 

\hyperlink{group__Timsort_gaf7991b9ef4ee31db5ae9f1fba5c04a15}{timsort\+\_\+collapse\+\_\+runs()} 

\hyperlink{group__InsertionSort_ga53e65861396bb4c67c0142dd41374727}{binary\+\_\+insert\+\_\+sort()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__Timsort_ga739626860caf26ad6fbe52f9dcb0806c}\label{group__Timsort_ga739626860caf26ad6fbe52f9dcb0806c}} 
\index{Timsorts@{Timsorts}!timsort\+\_\+check\+\_\+invariants@{timsort\+\_\+check\+\_\+invariants}}
\index{timsort\+\_\+check\+\_\+invariants@{timsort\+\_\+check\+\_\+invariants}!Timsorts@{Timsorts}}
\subsubsection{\texorpdfstring{timsort\+\_\+check\+\_\+invariants()}{timsort\_check\_invariants()}}
{\footnotesize\ttfamily void timsort\+\_\+check\+\_\+invariants (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare,  }\item[{\hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$}]{ms }\end{DoxyParamCaption})}



Maintain run invariants to ensure stable, balanced merges. 

Let X, Y and Z be the top 3 runs in the run stack, ordered from left to right. Then the following must hold\+:
\begin{DoxyEnumerate}
\item $\vert$\+X$\vert$ $>$ $\vert$\+Y$\vert$ + $\vert$\+Z$\vert$
\item $\vert$\+Y$\vert$ $>$ $\vert$\+Z$\vert$ If either invariant fails to hold, merge Y with smaller of X and Z and push new merged value onto stack, maintaing order.
\end{DoxyEnumerate}

\begin{DoxyNote}{Note}
If the runs stack contains only 2 runs, we still check that the second invariant holds.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em arr} & Array containing runs. \\
\hline
{\em size} & Size of each element in array. \\
\hline
{\em compare} & Function to compare elements. \\
\hline
{\em ms} & Struct containing information about merges and runs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort()} 

\hyperlink{group__Timsort_ga17b4bb9f7e1875e9e9e4c250b5b83482}{timsort\+\_\+find\+\_\+runs()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__Timsort_gaf7991b9ef4ee31db5ae9f1fba5c04a15}\label{group__Timsort_gaf7991b9ef4ee31db5ae9f1fba5c04a15}} 
\index{Timsorts@{Timsorts}!timsort\+\_\+collapse\+\_\+runs@{timsort\+\_\+collapse\+\_\+runs}}
\index{timsort\+\_\+collapse\+\_\+runs@{timsort\+\_\+collapse\+\_\+runs}!Timsorts@{Timsorts}}
\subsubsection{\texorpdfstring{timsort\+\_\+collapse\+\_\+runs()}{timsort\_collapse\_runs()}}
{\footnotesize\ttfamily void timsort\+\_\+collapse\+\_\+runs (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare,  }\item[{\hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$}]{ms }\end{DoxyParamCaption})}



Merge top two runs in run stack until only one run remains. 

Once all the runs have been merged, the array will be fully sorted.


\begin{DoxyParams}{Parameters}
{\em arr} & Array containing runs. \\
\hline
{\em size} & Size of each element in array. \\
\hline
{\em compare} & Function to compare elements. \\
\hline
{\em ms} & Struct containing information about merges and runs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort()} 

\hyperlink{group__Timsort_ga08929ad9e29cde3f24660fef3b08191c}{timsort\+\_\+merge\+\_\+runs()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__Timsort_ga17b4bb9f7e1875e9e9e4c250b5b83482}\label{group__Timsort_ga17b4bb9f7e1875e9e9e4c250b5b83482}} 
\index{Timsorts@{Timsorts}!timsort\+\_\+find\+\_\+runs@{timsort\+\_\+find\+\_\+runs}}
\index{timsort\+\_\+find\+\_\+runs@{timsort\+\_\+find\+\_\+runs}!Timsorts@{Timsorts}}
\subsubsection{\texorpdfstring{timsort\+\_\+find\+\_\+runs()}{timsort\_find\_runs()}}
{\footnotesize\ttfamily void timsort\+\_\+find\+\_\+runs (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{size\+\_\+t}]{nelems,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare,  }\item[{size\+\_\+t}]{minrun,  }\item[{\hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$}]{ms }\end{DoxyParamCaption})}



Find runs of elements in the array. 

A run is a sequence of either either strictly descending or non-\/descending elements. Because for any sequence of elements \{i, i+1\}, either arr\mbox{[}i\mbox{]} $>$ arr\mbox{[}i + 1\mbox{]} or arr\mbox{[}i\mbox{]} $<$= arr\mbox{[}i +1\mbox{]}, a run is always occuring.

Runs must be at least minrun elements long. If a run is shorter than this, it is extended using consecutive elements. There is one exception; the last run may be shorter if there are not enough elements to pad out its length.

Importantly, all runs must be non-\/descending before they can be pushed onto the runs stack -\/ runs which are descending are reveresed before they are pushed.

Once a new run has been found and pushed on the runs stack, the function calls \hyperlink{group__Timsort_ga739626860caf26ad6fbe52f9dcb0806c}{timsort\+\_\+check\+\_\+invariants()} to ensure that the run invariants still hold.


\begin{DoxyParams}{Parameters}
{\em arr} & Array to search for runs. \\
\hline
{\em nelems} & Number of elements in array. \\
\hline
{\em size} & Size of each element in array. \\
\hline
{\em compare} & Function to compare elements. \\
\hline
{\em minrun} & Minimum acceptable run length. \\
\hline
{\em ms} & Struct containing information about merges and runs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort()} 

\hyperlink{group__Timsort_ga739626860caf26ad6fbe52f9dcb0806c}{timsort\+\_\+check\+\_\+invariants()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__Timsort_ga61e102d0fe24f871260f90f9e40ba807}\label{group__Timsort_ga61e102d0fe24f871260f90f9e40ba807}} 
\index{Timsorts@{Timsorts}!timsort\+\_\+gallop\+\_\+left@{timsort\+\_\+gallop\+\_\+left}}
\index{timsort\+\_\+gallop\+\_\+left@{timsort\+\_\+gallop\+\_\+left}!Timsorts@{Timsorts}}
\subsubsection{\texorpdfstring{timsort\+\_\+gallop\+\_\+left()}{timsort\_gallop\_left()}}
{\footnotesize\ttfamily size\+\_\+t timsort\+\_\+gallop\+\_\+left (\begin{DoxyParamCaption}\item[{void $\ast$}]{src,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare,  }\item[{size\+\_\+t}]{base,  }\item[{size\+\_\+t}]{limit,  }\item[{void $\ast$}]{target }\end{DoxyParamCaption})}



Gallop right to left to find slice of elements in source array greater than target. 

In order to find this slice, we need to find the number of elements in the source array greater than the target. Given that the source array is sorted and ascending, it suffices to find where the target would be located in the source array.

To determine this location, we perform a pair of searches\+:
\begin{DoxyEnumerate}
\item We first perform an exponential search to find the value k such that base -\/ ((2$^\wedge$(k) -\/ 1) $\ast$ size $<$ target $<$= base -\/ ((2$^\wedge$(k-\/1) -\/ 1) $\ast$ size). This condenses the range of values in which the target must lie.
\item We then perform binary search using this range.
\end{DoxyEnumerate}

\begin{DoxyNote}{Note}
The slice is a memory offset corresponding to the total size of these elements.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em src} & Array to gallop over. \\
\hline
{\em size} & Size of each element in array. \\
\hline
{\em compare} & Function to compare elements. \\
\hline
{\em base} & Initial offset to begin gallop. \\
\hline
{\em limit} & Maximum offset for galloping (inclusive). \\
\hline
{\em target} & Target element. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total size of elements in souce array greater than target.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort()} 

\hyperlink{group__Timsort_ga5f8c1d718a58791f523430113eb5616e}{timsort\+\_\+merge\+\_\+runs\+\_\+hi()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__Timsort_gaf272b7c7b32279bc6aa2010330e7d980}\label{group__Timsort_gaf272b7c7b32279bc6aa2010330e7d980}} 
\index{Timsorts@{Timsorts}!timsort\+\_\+gallop\+\_\+right@{timsort\+\_\+gallop\+\_\+right}}
\index{timsort\+\_\+gallop\+\_\+right@{timsort\+\_\+gallop\+\_\+right}!Timsorts@{Timsorts}}
\subsubsection{\texorpdfstring{timsort\+\_\+gallop\+\_\+right()}{timsort\_gallop\_right()}}
{\footnotesize\ttfamily size\+\_\+t timsort\+\_\+gallop\+\_\+right (\begin{DoxyParamCaption}\item[{void $\ast$}]{src,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare,  }\item[{size\+\_\+t}]{base,  }\item[{size\+\_\+t}]{limit,  }\item[{void $\ast$}]{target }\end{DoxyParamCaption})}



Gallop left to right to find slice of elements in source array less than target. 

In order to find this slice, we need to find the number of elements in the source array smaller than the target. Given that the source array is sorted and ascendingr, it suffices to find where the target would be located in the source array.

To determine this location, we perform a pair of searches\+:
\begin{DoxyEnumerate}
\item We first perform an exponential search to find the value k such that base + ((2$^\wedge$(k-\/1) -\/ 1) $\ast$ size $<$ target $<$= base + ((2$^\wedge$k -\/ 1) $\ast$ size). This condenses the range of values in which the target must lie.
\item We then perform binary search using this range.
\end{DoxyEnumerate}

\begin{DoxyNote}{Note}
The slice is a memory offset corresponding to the total size of these elements.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em src} & Array to gallop over. \\
\hline
{\em size} & Size of each element in array. \\
\hline
{\em compare} & Function to compare elements. \\
\hline
{\em base} & Initial offset to begin gallop. \\
\hline
{\em limit} & Maximum offset for galloping (inclusive). \\
\hline
{\em target} & Target element. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Total size of elements in source array less than target.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort()} 

\hyperlink{group__Timsort_ga9ed838122eff00630e9551003d73a56f}{timsort\+\_\+merge\+\_\+runs\+\_\+lo()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__Timsort_ga08929ad9e29cde3f24660fef3b08191c}\label{group__Timsort_ga08929ad9e29cde3f24660fef3b08191c}} 
\index{Timsorts@{Timsorts}!timsort\+\_\+merge\+\_\+runs@{timsort\+\_\+merge\+\_\+runs}}
\index{timsort\+\_\+merge\+\_\+runs@{timsort\+\_\+merge\+\_\+runs}!Timsorts@{Timsorts}}
\subsubsection{\texorpdfstring{timsort\+\_\+merge\+\_\+runs()}{timsort\_merge\_runs()}}
{\footnotesize\ttfamily void timsort\+\_\+merge\+\_\+runs (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare,  }\item[{\hyperlink{structTimsortRun}{Timsort\+Run} $\ast$}]{left,  }\item[{\hyperlink{structTimsortRun}{Timsort\+Run} $\ast$}]{right,  }\item[{\hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$}]{ms }\end{DoxyParamCaption})}



Merge two consecutive runs. 

To optimize merges, the function first finds the locations of right\mbox{[}0\mbox{]} in left\mbox{[}\mbox{]} (lo), and left\mbox{[}max\mbox{]} in right\mbox{[}\mbox{]} (hi). As runs are increasing, all values in left\mbox{[}\mbox{]} before \textquotesingle{}lo\textquotesingle{} are smaller than all value in right\mbox{[}\mbox{]}, and likewise all values in right above \textquotesingle{}hi\textquotesingle{} are greater than all values in left\mbox{[}\mbox{]}. These values can be ignored during the merge.


\begin{DoxyParams}{Parameters}
{\em arr} & Array containing runs. \\
\hline
{\em size} & Size of each element in array. \\
\hline
{\em compare} & Function to compare elements. \\
\hline
{\em left} & Leftmost run. \\
\hline
{\em right} & Rightmost run. \\
\hline
{\em ms} & Struct containing information about merges and runs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to left run, now with length updated to include right\textquotesingle{}s.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort()} 

\hyperlink{group__Timsort_ga739626860caf26ad6fbe52f9dcb0806c}{timsort\+\_\+check\+\_\+invariants()} 

\hyperlink{group__Timsort_gaf7991b9ef4ee31db5ae9f1fba5c04a15}{timsort\+\_\+collapse\+\_\+runs()} 

\hyperlink{group__Timsort_ga9ed838122eff00630e9551003d73a56f}{timsort\+\_\+merge\+\_\+runs\+\_\+lo()} 

\hyperlink{group__Timsort_ga5f8c1d718a58791f523430113eb5616e}{timsort\+\_\+merge\+\_\+runs\+\_\+hi()} 

\hyperlink{group__SortingHelper_ga347d3eac5748d59424afd8566181fc27}{bin\+\_\+search\+\_\+loc()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__Timsort_ga5f8c1d718a58791f523430113eb5616e}\label{group__Timsort_ga5f8c1d718a58791f523430113eb5616e}} 
\index{Timsorts@{Timsorts}!timsort\+\_\+merge\+\_\+runs\+\_\+hi@{timsort\+\_\+merge\+\_\+runs\+\_\+hi}}
\index{timsort\+\_\+merge\+\_\+runs\+\_\+hi@{timsort\+\_\+merge\+\_\+runs\+\_\+hi}!Timsorts@{Timsorts}}
\subsubsection{\texorpdfstring{timsort\+\_\+merge\+\_\+runs\+\_\+hi()}{timsort\_merge\_runs\_hi()}}
{\footnotesize\ttfamily void timsort\+\_\+merge\+\_\+runs\+\_\+hi (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare,  }\item[{size\+\_\+t}]{lo,  }\item[{size\+\_\+t}]{lo\+\_\+len,  }\item[{size\+\_\+t}]{hi,  }\item[{size\+\_\+t}]{hi\+\_\+len,  }\item[{\hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$}]{ms }\end{DoxyParamCaption})}



Merge two consecutive runs from right to left. 

This function is called when the rightmost run is smaller than the leftmost run. There are two modes in which merges can be performed\+:

Standard mode\+: Standard merge sort where elements are compared one-\/to-\/one. During this mode, we keep track of the \char`\"{}winning\char`\"{} array. If an array has \char`\"{}won\char`\"{} more than the ms-\/$>$min\+\_\+gallop, we enter galloping mode.

Galloping Mode (galloping left)\+: In galloping mode, merges are performed as a pair of operations\+:
\begin{DoxyEnumerate}
\item Find the location of right\mbox{[}max\mbox{]} in left\mbox{[}\mbox{]}. Merge all values (slice1) in left\mbox{[}\mbox{]} down to this point and then merge right\mbox{[}max\mbox{]}.
\item Find the location of left\mbox{[}max\mbox{]} in right\mbox{[}\mbox{]}. Merge all values (slice2) in right\mbox{[}\mbox{]} down to this point and then merge left\mbox{[}max\mbox{]}. Note\+: The runs left\mbox{[}\mbox{]} and right\mbox{[}\mbox{]} are altered between these operations.
\end{DoxyEnumerate}

Galloping mode lets us take advantage of subruns in data, and by performing merges in bulk, can be quite efficient for certain types of data. However, galloping is not always effective. In particular, it is not at all efficient with random data.

To account for this, we check after the above operations that slice1 and slice2 are both sufficiently large -\/ at least as large as ms-\/$>$min\+\_\+gallop $\ast$ element\+\_\+size. If this is the case, then galloping mode was effective and we decrement ms-\/$>$min\+\_\+gallop to make subsequent returns to galloping mode easier. If this wasn\textquotesingle{}t the case, we exit galloping mode and increment ms-\/$>$min\+\_\+gallop to make entering galloping mode harder. In this way, the algorithm quickly reacts to data for which galloping is ill-\/suited and limits its effect on performance.


\begin{DoxyParams}{Parameters}
{\em arr} & Array containing runs. \\
\hline
{\em size} & Size of each element in array. \\
\hline
{\em compare} & Function to compare elements. \\
\hline
{\em lo} & Lower bound of merge (inclusive). \\
\hline
{\em lo\+\_\+len} & Length of larger leftmost run. \\
\hline
{\em hi} & Upper bound of merge (inclusive). \\
\hline
{\em hi\+\_\+len} & Length of smaller rightmost run. \\
\hline
{\em ms} & Struct containing information about merges and runs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort()} 

\hyperlink{group__Timsort_ga08929ad9e29cde3f24660fef3b08191c}{timsort\+\_\+merge\+\_\+runs()} 

\hyperlink{group__Timsort_ga61e102d0fe24f871260f90f9e40ba807}{timsort\+\_\+gallop\+\_\+left()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__Timsort_ga9ed838122eff00630e9551003d73a56f}\label{group__Timsort_ga9ed838122eff00630e9551003d73a56f}} 
\index{Timsorts@{Timsorts}!timsort\+\_\+merge\+\_\+runs\+\_\+lo@{timsort\+\_\+merge\+\_\+runs\+\_\+lo}}
\index{timsort\+\_\+merge\+\_\+runs\+\_\+lo@{timsort\+\_\+merge\+\_\+runs\+\_\+lo}!Timsorts@{Timsorts}}
\subsubsection{\texorpdfstring{timsort\+\_\+merge\+\_\+runs\+\_\+lo()}{timsort\_merge\_runs\_lo()}}
{\footnotesize\ttfamily void timsort\+\_\+merge\+\_\+runs\+\_\+lo (\begin{DoxyParamCaption}\item[{void $\ast$}]{arr,  }\item[{size\+\_\+t}]{size,  }\item[{int($\ast$)(const void $\ast$, const void $\ast$)}]{compare,  }\item[{size\+\_\+t}]{lo,  }\item[{size\+\_\+t}]{lo\+\_\+len,  }\item[{size\+\_\+t}]{hi,  }\item[{size\+\_\+t}]{hi\+\_\+len,  }\item[{\hyperlink{structTimsortMergeState}{Timsort\+Merge\+State} $\ast$}]{ms }\end{DoxyParamCaption})}



Merge two consecutive runs from left to right. 

This function is called when the leftmost run is smaller than the rightmost run. There are two modes in which merges can be performed\+:

Standard mode\+: Standard merge sort where elements are compared one-\/to-\/one. During this mode, we keep track of the \char`\"{}winning\char`\"{} array. If an array has \char`\"{}won\char`\"{} more than the ms-\/$>$min\+\_\+gallop, we enter galloping mode.

Galloping Mode (galloping right)\+: In galloping mode, merges are performed as a pair of operations\+:
\begin{DoxyEnumerate}
\item Find the location of left\mbox{[}0\mbox{]} in right\mbox{[}\mbox{]}. Merge all values (slice1) in right\mbox{[}\mbox{]} up to this point and then merge left\mbox{[}0\mbox{]}.
\item Find the location of right\mbox{[}0\mbox{]} in left\mbox{[}\mbox{]}. Merge all values (slice2) in left\mbox{[}\mbox{]} up to this point and then merge right\mbox{[}0\mbox{]}. Note\+: The runs left\mbox{[}\mbox{]} and right\mbox{[}\mbox{]} are altered between these operations.
\end{DoxyEnumerate}

Galloping mode lets us take advantage of subruns in data, and by performing merges in bulk, can be quite efficient for certain types of data. However, galloping is not always effective. In particular, it is not at all efficient with random data.

To account for this, we check after the above operations that slice1 and slice2 are both sufficiently large -\/ at least as large as ms-\/$>$min\+\_\+gallop $\ast$ element\+\_\+size. If this is the case, then galloping mode was effective and we decrement ms-\/$>$min\+\_\+gallop to make subsequent returns to galloping mode easier. If this wasn\textquotesingle{}t the case, we exit galloping mode and increment ms-\/$>$min\+\_\+gallop to make entering galloping mode harder. In this way, the algorithm quickly reacts to data for which galloping is ill-\/suited and limits its effect on performance.


\begin{DoxyParams}{Parameters}
{\em arr} & Array containing runs. \\
\hline
{\em size} & Size of each element in array. \\
\hline
{\em compare} & Function to compare elements. \\
\hline
{\em lo} & Lower bound of merge (inclusive). \\
\hline
{\em lo\+\_\+len} & Length of smaller leftmost run. \\
\hline
{\em hi} & Upper bound of merge (inclusive). \\
\hline
{\em hi\+\_\+len} & Length of larger rightmost run. \\
\hline
{\em ms} & Struct containing information about merges and runs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort()} 

\hyperlink{group__Timsort_ga08929ad9e29cde3f24660fef3b08191c}{timsort\+\_\+merge\+\_\+runs()} 

\hyperlink{group__Timsort_gaf272b7c7b32279bc6aa2010330e7d980}{timsort\+\_\+gallop\+\_\+right()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__Timsort_ga7d1b40d5d91736aa4b5362896cdc68f3}\label{group__Timsort_ga7d1b40d5d91736aa4b5362896cdc68f3}} 
\index{Timsorts@{Timsorts}!timsort\+\_\+minrun@{timsort\+\_\+minrun}}
\index{timsort\+\_\+minrun@{timsort\+\_\+minrun}!Timsorts@{Timsorts}}
\subsubsection{\texorpdfstring{timsort\+\_\+minrun()}{timsort\_minrun()}}
{\footnotesize\ttfamily size\+\_\+t timsort\+\_\+minrun (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{nelems }\end{DoxyParamCaption})}



Find minimum run size to use in timsort. 

The minimum run size is given by the 6 most significant bits of the array\textquotesingle{}s length. Consequently, minrun will range between 32 and 64 inclusive, and any array with length $<$ 64 will have minimum run size equal to their entire length.


\begin{DoxyParams}{Parameters}
{\em nelems} & Number of elements in array. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Size of minimum run.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__Timsort_ga1c9fca70060e37617156b89b387aa4d3}{timsort()} 
\end{DoxySeeAlso}
